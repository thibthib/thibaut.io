export const meta = {
  title: 'Evolution of Refs',
  description: 'With great power comes great responsability',
  date: 'July 27, 2019',
};

In React apps, for some use-cases we still need to handle DOM elements directly. One example is focus management. To give an input element focus without the user clicking on it, we need to call [`input.focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus). The way to achieve it is to use React Refs.

## üéà Strings

The first Refs API was quite simple. We had to add a `ref` prop with a string name on any element for it to be available on your class component:

```jsx
class MyComponent extends Component {
  componentDidMount() {
    this.refs.input.focus();
  }
  render() {
    return <input ref={'input'} />;
  }
}
```

But this API design was not without [some](https://github.com/facebook/react/issues/1373) [issues](https://github.com/facebook/react/pull/8333#issuecomment-271648615), like the inability to get several Refs on a single element. So the React team came up with a new solution.

## üìû Callbacks

This time, we pass a function in the `ref` prop, that takes the DOM element as its argument. We can then store this element and use it later.

```jsx
class MyComponent extends Component {
  componentDidMount() {
    if (this.input !== null) {
      this.input.focus();
    }
  }
  render() {
    return <input ref={element => (this.input = element)} />;
  }
}
```

With a much finer control over how to handle Refs, most issues with the string API are solved ! We can now have two components that have their own Ref on a single element. This is, to date, the most flexible way to handle Refs.

But this API design has some flaws. It's a bit more complex to handle that the string name API, and it has some subleties that can bite. For example, when the `ref` prop is an inline function, every render [will call it twice](https://reactjs.org/docs/refs-and-the-dom.html#caveats-with-callback-refs): first with `null`, then with the element. It's not the case with class methods, but it's easy to forget that we need to check if the element is not null before consuming it.

## üê£ `createRef`

With the version 16.3, a new `createRef` API was released:

```jsx
class MyComponent extends Component {
  constructor(props) {
    super(props);
    this.inputRef = React.createRef();
  }
  componentDidMount() {
    if (this.inputRef.current !== null) {
      this.inputRef.current.focus();
    }
  }
  render() {
    return <input ref={this.inputRef} />;
  }
}
```

It aims to restore the convenience of using string Refs without their drawbacks. We don't have to handle the element assignment to a local variable in every render anymore ! We now get a `RefObject` to consume, with a `current` property that will hold the DOM element, as its TypeScript definition shows:

```ts
interface RefObject<T> {
  readonly current: T | null;
}
```

But a big piece was still missing: function components support.

## üé£ `useRef`

Along with many other things, React 16.8 brought the new `useRef` hook.

```jsx
const MyComponent = () => {
  const inputRef = React.useRef(null);

  // React.useEffect(fn, []) is the hook way of
  // of calling a function when the component mounts
  // https://reactjs.org/docs/hooks-effect.html
  React.useEffect(() => {
    if (inputRef.current !== null) {
      inputRef.current.focus();
    }
  }, []);

  return <input ref={inputRef} />;
};
```

And `useRef` can be used to do more that holding a DOM element. It has been designed to hold any value accross renders in a function component. It's a replacement of the simple `this.myVariable` we can use in class components. The TypeScript definition of the returned object is a bit different than the one from `createRef`: the `current` property is not `readonly` anymore:

```ts
interface MutableRefObject<T> {
  current: T;
}
```

## ‚è© `forwardRef`

The last way of getting access to a DOM element is with `forwardRef`. The particularity of this one is that you can get a Ref on a child component's element directly.

```jsx
const MyInput = React.forwardRef((props, ref) => <input ref={ref} />);

const MyComponent = () => {
  const childRef = React.useRef(null);

  React.useEffect(() => {
    if (childRef.current !== null) {
      childRef.current.focus();
    }
  }, []);

  return <MyInput ref={childRef} />;
};
```

The parent component can use `createRef`, `useRef` or callback refs, so the `ref` parameter received from `forwardRef` is of a new type:

```ts
type Ref<T> = (instance: T | null) => void | RefObject<T> | null;
```

_Note: The [actual definition](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts#L84) is a bit different, but the difference is not really relevant to our subject._

_Second note: In the future this API [could be simplified](https://github.com/reactjs/rfcs/pull/107), removing the need for using `React.forwardRef` altogether._

## üéÅ `useImperativeHandle`

React Refs can handle more than only DOM elements. We already saw we can store mutable values in function components with the `useRef` hook. They were also designed to handle component instances since the beginning. When adding a `ref` prop on a custom component that does not implement `forwardRef`, we get its instance instead of a DOM element.

With the `useImperativeHandle` hook, we can go even further and decide what our component will return via its `ref` prop. It can be pretty useful when we need to have both a local Ref and a forwarded one:

```jsx
const MyInput = React.forwardRef((props, forwardedRef) => {
  const localRef = React.useRef(null);

  React.useEffect(() => {
    if (localRef.current !== null) {
      localRef.current.focus();
    }
  }, []);

  // this way, the local Ref is also exposed as a forwarded one
  React.useImperativeHandle(forwardedRef, () => localRef.current);

  return <input ref={localRef} />;
});
```

## ‚ö†Ô∏è With great power comes great responsability

As we have seen, there is a lot of different ways to use Refs and get access to a DOM element. But their usage should be very limited to [some specific use-cases](https://reactjs.org/docs/refs-and-the-dom.html#when-to-use-refs). React Refs can be seen as an escape hatch, for when the framework fails to provide a declarative API for a use-case. As such, they should be used only when there is no other way.

The React team knows that focus management [is hard](https://github.com/reactjs/rfcs/issues/104) to manage in React apps, and [new APIs](https://github.com/facebook/react/issues/16009) could fill this need in the future. Keep an eye on their repositories to see how this RFC evolves !

üëã
