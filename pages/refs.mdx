import { css, Global } from '@emotion/core';

# ðŸŽ¯ React Refs ðŸŽ¯

React is all about not having to interact with the DOM directly, like we could do with jQuery for example. But the abstraction does not cover all use cases, like handling the focus for example: you still need a DOM node to be able to give it focus. That's why refs were added.

At first, the API was quite simple. You just had to add a `ref` prop with a name for it to be available on your class component.

```jsx
class MyComponent extends Component {
  componentDidMount() {
    this.refs.textInput.focus();
  }
  render() {
    return <input ref={'textInput'} />;
  }
}
```

But this API design was not [without issues](https://github.com/facebook/react/pull/8333#issuecomment-271648615).

The solution was to use callback refs, a new API:

```jsx
class MyComponent extends Component {
  componentDidMount() {
    this.textInput.focus();
  }
  render() {
    return (
      <input
        ref={node => {
          this.textInput = node;
        }}
      />
    );
  }
}
```

But this API design also had some flaws. For example, the above example could lead to `undefined` node at some point, and this often ended up in errors in your console. In my example, this was due because the `ref` callback is an inline function, and so at every render it changes. And when the ref callback changed, React first calls the previous version with `undefined`, and then called the new one with the actual `node` value. To fix this issue, we just had to use a class function:

```jsx
class MyComponent extends Component {
  componentDidMount() {
    this.textInput.focus();
  }
  setRef(node) {
    this.textInput = node;
  }
  render() {
    return <input ref={this.setRef} />;
  }
}
```

This was an easy mistake to make, that bite us a couple times in the past !

And then in 16.3 a new `createRef` API was released.

```jsx
class MyComponent extends Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }
  componentDidMount() {
    this.textInput.current.focus();
  }
  render() {
    return <input ref={this.textInput} />;
  }
}
```

(

  <Global
    styles={css`
      body {
        background-color: #021c31;
        color: #d6deeb;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Oxygen-Sans", Ubuntu, Cantarell, "Helvetica Neue";
        margin: 12vw auto;
        font-size: 1.2em;
        max-width: 900px;
        line-height: 1.4;
      }
    `}
  />
)````
