import { RandomHexagons } from '../components/hexagons/RandomHexagons';
import { EditOnCodeSandbox } from '../components/EditOnCodeSandbox';
import { css } from '@emotion/core';

export const meta = {
  title: 'React + Canvas = üíú',
  description: 'an untold love story',
  date: 'January 12, 2019',
};

The `<canvas/>` HTML element can be used to draw graphics with a finer control than the usual DOM or SVG. But with React, trying to draw on a canvas is not intuitive as their interfaces are quite different. With React, each component own their node contrary to canvas where there is only one shared node, and we draw in it. Let's see how we can make a canvas visualization with React components !

## üßë‚Äçüè´ Canvas 101

The `canvas` element is like a sheet of paper. To draw in real life, you would take a pen, move your hand to a first position, and draw a line by moving your hand to another position. The browser API to draw on a canvas is actually very similar. We first need to make a blueprint of the shape we want to draw (like using a wood pencil), and then we can color it.

```js
// moving our hand to the starting position
canvasContext.moveTo(x1, y1);
// drawing a blueprint line to the finishing position
canvasContext.lineTo(x2, y2);
// taking a purple pen and coloring the line
canvasContext.strokeStyle = 'purple';
canvasContext.stroke();
```

Having imperative code like this in a component oriented codebase can be tricky ! Let's create a component that renders a `<canvas />` on the page. Then, we need to call the `moveTo` and `lineTo` methods on it to draw a line. In practice, it's a bit more complicated to bridge those two. We need to use a [React reference](https://thibaut.io/react-refs-evolution) to access the canvas DOM node, then need to get a 2D context out of it, and finally we can call our drawing methods. The code looks like that:

```jsx basic-canvas-hs3cy src/App.js
const Canvas = () => {
  // we use a ref to access the canvas' DOM node
  const canvasRef = React.useRef(null);

  React.useEffect(() => {
    const context = canvasRef.current.getContext('2d');
    // ...drawing using the context
  }, [canvasRef]);

  return <canvas ref={canvasRef} />;
};
```

But if we want to draw something a bit more complex, the `Canvas` component can become quite large. Usually, big components are split into several child components. Yet here, this is not possible as there is only one `canvas` node.

## üé® Hexagons

To show how to make child components with canvas, let's draw something more fancy ‚ú®

<div
  style={{
    height: '360px',
    width: '100%',
  }}
>
  <RandomHexagons isAnimating={true} />
</div>

A single hexagon is defined with the folowing data:

- A position on the screen, defined by two `x` and `y` number values.
- A `radius` that defines its size.
- A `rotation` so that all hexagons don't look aligned.
- A `color`.

We need a function that is able to generate some random hexagons to display. The randomisation code is not relevant here, let's assume we have a way to get an array of hexagons. As for how to draw the shape of an hexagon, we need to draw a line between all its corners, and then fill it with a color:

```jsx
// This article explains all the math behind hexagons
// https://www.redblobgames.com/grids/hexagons/
const corners = getHexagonCorners(x, y, radius, rotation);

context.beginPath();
corners.forEach((corner, index) => {
  if (index === 0) {
    context.moveTo(corner.x, corner.y);
  } else {
    context.lineTo(corner.x, corner.y);
  }
});
context.fillStyle = color;
context.fill();
```

Now, how could we extract this logic into its own `Hexagon` component ? We need the canvas' context to draw anything on it. We could pass it to all the child components via a prop, but this approach can be a bit tedious when children are nested. Another way of doing this is by using a [React context](https://reactjs.org/docs/context.html) to share "global" values between components.

## üì¶ A context in a context

At this point the naming gets a bit tricky as we are trying to share a canvas' _context_ via a React _context_. Once we create a React context, we need to use the context's `Provider` to share a value. In the case of our `Canvas` component, which would look like this:

```jsx hexagons-30dkf src/Canvas.js
// we create a React context with a _null_ default value
const SharingContext = React.createContext(null);

const Canvas = props => {
  const canvasRef = React.useRef(null);
  const [renderingContext, setRenderingContext] = React.useState(null);

  // the canvas rendering context is not immediately avalaible
  // as the canvas node first needs to be added to the DOM by react
  React.useEffect(() => {
    const context2d = canvasRef.current.getContext('2d');
    setRenderingContext(context2d);
  }, []);

  return (
    <SharingContext.Provider value={renderingContext}>
      <canvas ref={canvasRef} />
      {/* the hexagons are passed through the `children` prop */}
      {props.children}
    </SharingContext.Provider>
  );
};
```

The `Hexagon` component needs to consume this React context to read its value ‚Äì here with the `useContext` hook.

```jsx hexagons-30dkf src/Hexagon.js
const Hexagon = props => {
  // we get the rendering context by comsuming the React context
  const renderingContext = React.useContext(SharingContext);

  if (renderingContext !== null) {
    // hexagon drawing logic
  }
};
```

Now, both our `Canvas` and `Hexagon` components are ready. We can display several random hexagons:

```jsx hexagons-30dkf src/App.js
const App = () => (
  <Canvas>
    {getRandomHexagons().map(hexagon => (
      <Hexagon {...hexagon} />
    ))}
  </Canvas>
);
```

The last thing we need is to animate the hexagons so that they rotate.

## üé¨ Animations

As we saw, the canvas is like a sheet of paper: once we've drawn on it, we can't change it! But we can clear the canvas and re-draw on it. Animating on a canvas is like animating cartoons. It's a lots of draw, clean, draw, clean, repeat! To make a shape move, you need to split the movement into small steps, draw them one by one, while clearing the canvas between them. Those steps are called frames. Browsers come with an API `requestAnimationFrame` so that you can draw in each frame. 

### üñº Creating a frame loop

First things first, the canvas should be cleared at each frame. The easiest way to do this is to have an internal state counting the frames. This way, the component re-renders at each frame:

```jsx animated-hexagons-v9j2q src/Canvas.js
const [frameCount, setFrameCount] = React.useState(0);
// this effect will increment frameCount by one at the next frame
// and is called every time frameCount changes, creating a recursive loop
// this makes the Canvas component re-render at every frame
React.useEffect(() => {
  const frameId = requestAnimationFrame(() => {
    setFrameCount(frameCount + 1);
  });
  return () => {
    cancelAnimationFrame(frameId);
  };
}, [frameCount, setFrameCount]);

// here's the clearing at every render ‚Äî at every frame.
if (context !== null) {
  context.clearRect(0, 0, actualWidth, actualHeight);
}
```

But... the canvas is now white! It's because the hexagons are only rendered once ‚Äì when `<RandomHexagons />` is first rendered. Yet, the canvas is cleared at every frame, erasing the hexagons on the second frame. Children components should also draw in the canvas at every frame. To force them to re-render, one solution is to share the `frameCount` from the canvas with the `Hexagon` component. It's achieved via a React context, like we did with `SharingContext`:

```jsx
const FrameContext = React.createContext(0);

const Canvas = props => {
  // [...]
  return (
    <SharingContext.Provider value={renderingContext}>
      <FrameContext.Provider value={frameCount}>
        <canvas />
        {props.children}
      </FrameContext.Provider>
    </SharingContext.Provider>
  );
};
```

```jsx
const Hexagon = props => {
  const renderingContext = React.useContext(SharingContext);
  const frameCount = React.useContext(FrameContext);
  // drawing logic
};
```

And now our hexagons are back on the screen! üéâ While this works, the `FrameContext` has to be added in every child component. Two options are available to make sure those two contexts are being consumed together:

- We can regroup them in a single context, sharing both the `renderingContext` and the `frameCount`. But the `frameCount` variable is not used in the child components, so it does not make sense to share its value.

- Or, we can create a `useCanvas` hook to hide this complexity away! Even when consuming both React contexts, the hook can only return the canvas rendering context to the child components:

```jsx
export const useCanvas = () => {
  React.useContext(FrameContext);
  const renderingContext = React.useContext(CanvasContext);
  return renderingContext;
};
```

The `Hexagon` component logic now needs a small update to use this new hook:

```jsx
const Hexagon = props => {
  const renderingContext = useCanvas();
  // drawing logic
};
```

### üîÑ Making the hexagons move

If we want the hexagons to rotate, each hexagon should have its rotation angle change at every frame-by incrementing it by 1 for example-. To do this, the hexagons needs to _remember_ the rotation from the previous render. We will use a [React ref](/react-refs-evolution) to achieve this:

```jsx
const animatedRotation = React.useRef(props.rotation);
animatedRotation.current = animatedRotation.current + 1;
```

As the `Hexagon` component re-renders at every frame, this code makes its rotation  change at every frame: they rotate! üòç

Like we did with `useCanvas`, we can also improve a bit the readability of this code by hiding the implementation detail ‚Äì here, using a React ref ‚Äì in a hook:

```jsx animated-hexagons-v9j2q src/Canvas.js
const useAnimation = (initialValue, valueUpdater) => {
  const animatedValue = React.useRef(initialValue);
  animatedValue.current = valueUpdater(animatedValue.current);
  return animatedValue.current;
};
```

The `Hexagon` code now looks a bit better:

```jsx animated-hexagons-v9j2q src/Hexagon.js
const Hexagon = props => {
  // [...]
  const animatedRotation = useAnimation(props.rotation, angle => angle + 1);
  // drawing logic
};
```

üëè Congratulations üëè We now have animated canvas-based React components! We even created two custom hooks along the way to make our code nicer.

## üëÄ Going further

- At some point it can become quite CPU heavy to try to animate a lot of shapes in a canvas. At this point, there's another more performant way to draw things: WebGL. It's a huge subject on its own! I would recommend you to look at how to write WebGL based components with [react-three-fiber](https://github.com/react-spring/react-three-fiber) _‚Äî spoiler alert, they made their own React reconciler_

- Our `useAnimation` hook is not helping if we want to animate stuff other than infinitely changing numbers. To create more complex ones, [react-spring](https://github.com/react-spring/react-spring) is the library to go. It needs a bit of wiring to have it work with our own frame loop ‚Äì [here's how it's done to work with `react-three-fiber` for example](https://github.com/react-spring/react-spring/blob/bdf8afb8b2d837fd756f8ffaae6931fb15c0e3d2/src/targets/three/index.ts#L24-L25).
